import os
import logging
import fitz  # PyMuPDF
import pandas as pd
from pathlib import Path

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def save_file(uploaded_file, data_folder="data"):
    """
    Save uploaded file to the data folder with validation and error handling
    
    Args:
        uploaded_file: Streamlit uploaded file object
        data_folder (str): Destination folder for the file
        
    Returns:
        str: Path to saved file
        
    Raises:
        ValueError: If file validation fails
        IOError: If file saving fails
    """
    try:
        # Create data folder if it doesn't exist
        os.makedirs(data_folder, exist_ok=True)
        
        # Validate file
        if not uploaded_file.name:
            raise ValueError("File has no name")
        
        # Check file extension
        allowed_extensions = ['.pdf', '.csv']
        file_extension = Path(uploaded_file.name).suffix.lower()
        
        if file_extension not in allowed_extensions:
            raise ValueError(f"Unsupported file type: {file_extension}. Allowed: {allowed_extensions}")
        
        # Check file size (limit to 50MB)
        file_size = len(uploaded_file.getvalue())
        max_size = 50 * 1024 * 1024  # 50MB
        
        if file_size > max_size:
            raise ValueError(f"File too large: {file_size / (1024*1024):.1f}MB. Maximum allowed: {max_size / (1024*1024)}MB")
        
        # Generate safe filename
        safe_filename = "".join(c for c in uploaded_file.name if c.isalnum() or c in '._-')
        file_path = os.path.join(data_folder, safe_filename)
        
        # Handle duplicate filenames
        counter = 1
        original_path = file_path
        while os.path.exists(file_path):
            name_parts = Path(original_path).stem, Path(original_path).suffix
            file_path = os.path.join(data_folder, f"{name_parts[0]}_{counter}{name_parts[1]}")
            counter += 1
        
        # Save file
        with open(file_path, "wb") as f:
            f.write(uploaded_file.getvalue())
        
        logger.info(f"Successfully saved file: {file_path} ({file_size / 1024:.1f}KB)")
        return file_path
        
    except Exception as e:
        logger.error(f"Error saving file {uploaded_file.name}: {e}")
        raise

def load_pdf(file_path):
    """
    Load and extract text from a PDF file
    
    Args:
        file_path (str): Path to PDF file
        
    Returns:
        str: Extracted text content
    """
    try:
        doc = fitz.open(file_path)
        text_content = []
        
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            text = page.get_text()
            
            # Clean up text
            text = text.strip()
            if text:  # Only add non-empty pages
                text_content.append(f"--- Page {page_num + 1} ---\n{text}")
        
        doc.close()
        
        if not text_content:
            logger.warning(f"No text extracted from PDF: {file_path}")
            return ""
        
        full_text = "\n\n".join(text_content)
        logger.info(f"Extracted {len(full_text)} characters from PDF: {file_path}")
        return full_text
        
    except Exception as e:
        logger.error(f"Error loading PDF {file_path}: {e}")
        return ""

def load_csv(file_path):
    """
    Load and process a CSV file
    
    Args:
        file_path (str): Path to CSV file
        
    Returns:
        str: CSV content as formatted text
    """
    try:
        # Try different encodings
        encodings = ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']
        df = None
        
        for encoding in encodings:
            try:
                df = pd.read_csv(file_path, encoding=encoding)
                logger.info(f"Successfully loaded CSV with {encoding} encoding")
                break
            except UnicodeDecodeError:
                continue
        
        if df is None:
            logger.error(f"Could not read CSV file with any encoding: {file_path}")
            return ""
        
        # Basic data validation
        if df.empty:
            logger.warning(f"CSV file is empty: {file_path}")
            return ""
        
        # Create a comprehensive text representation
        text_parts = []
        
        # Add basic info
        text_parts.append(f"CSV File: {os.path.basename(file_path)}")
        text_parts.append(f"Rows: {len(df)}, Columns: {len(df.columns)}")
        text_parts.append(f"Columns: {', '.join(df.columns.tolist())}")
        text_parts.append("")
        
        # Add data types info
        text_parts.append("Data Types:")
        for col, dtype in df.dtypes.items():
            text_parts.append(f"  {col}: {dtype}")
        text_parts.append("")
        
        # Add summary statistics for numeric columns
        numeric_cols = df.select_dtypes(include=['number']).columns
        if len(numeric_cols) > 0:
            text_parts.append("Numeric Summary:")
            summary = df[numeric_cols].describe()
            text_parts.append(summary.to_string())
            text_parts.append("")
        
        # Add sample data (first 10 rows)
        text_parts.append("Sample Data (first 10 rows):")
        sample_data = df.head(10).to_string(index=False)
        text_parts.append(sample_data)
        
        # Add unique values for categorical columns (if small enough)
        categorical_cols = df.select_dtypes(include=['object']).columns
        for col in categorical_cols:
            unique_vals = df[col].nunique()
            if unique_vals <= 20:  # Only show if reasonable number
                text_parts.append(f"\nUnique values in '{col}': {', '.join(map(str, df[col].unique()))}")
        
        full_text = "\n".join(text_parts)
        logger.info(f"Processed CSV: {file_path} ({len(df)} rows, {len(df.columns)} columns)")
        return full_text
        
    except Exception as e:
        logger.error(f"Error loading CSV {file_path}: {e}")
        return ""

def load_docs(folder):
    """
    Load all supported documents from a folder
    
    Args:
        folder (str): Path to folder containing documents
        
    Returns:
        list: List of extracted text content from documents
    """
    docs = []
    
    if not os.path.exists(folder):
        logger.warning(f"Folder does not exist: {folder}")
        return docs
    
    files = os.listdir(folder)
    if not files:
        logger.warning(f"No files found in folder: {folder}")
        return docs
    
    logger.info(f"Processing {len(files)} files from {folder}")
    
    for filename in files:
        file_path = os.path.join(folder, filename)
        
        # Skip directories
        if os.path.isdir(file_path):
            continue
        
        try:
            text_content = ""
            
            if filename.lower().endswith('.pdf'):
                logger.info(f"Processing PDF: {filename}")
                text_content = load_pdf(file_path)
                
            elif filename.lower().endswith('.csv'):
                logger.info(f"Processing CSV: {filename}")
                text_content = load_csv(file_path)
                
            else:
                logger.warning(f"Unsupported file type: {filename}")
                continue
            
            if text_content.strip():
                docs.append(text_content)
                logger.info(f"✅ Successfully processed: {filename}")
            else:
                logger.warning(f"⚠️ No content extracted from: {filename}")
                
        except Exception as e:
            logger.error(f"❌ Error processing {filename}: {e}")
            continue
    
    logger.info(f"Successfully loaded {len(docs)} documents")
    return docs

def get_file_info(file_path):
    """
    Get information about a file
    
    Args:
        file_path (str): Path to file
        
    Returns:
        dict: File information
    """
    try:
        if not os.path.exists(file_path):
            return None
        
        stat = os.stat(file_path)
        
        info = {
            'name': os.path.basename(file_path),
            'size_bytes': stat.st_size,
            'size_mb': stat.st_size / (1024 * 1024),
            'modified': stat.st_mtime,
            'extension': Path(file_path).suffix.lower()
        }
        
        # Add specific info based on file type
        if info['extension'] == '.pdf':
            try:
                doc = fitz.open(file_path)
                info['pages'] = len(doc)
                doc.close()
            except:
                info['pages'] = 'Unknown'
                
        elif info['extension'] == '.csv':
            try:
                df = pd.read_csv(file_path, nrows=0)  # Just read headers
                info['columns'] = len(df.columns)
                info['column_names'] = df.columns.tolist()
            except:
                info['columns'] = 'Unknown'
        
        return info
        
    except Exception as e:
        logger.error(f"Error getting file info for {file_path}: {e}")
        return None
